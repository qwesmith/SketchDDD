# Java Code Generation

SketchDDD generates modern Java code using records and sealed interfaces.

## Generation

```bash
sketchddd codegen domain.sddd --target java --output ./src/main/java/domain
```

## Features

- **Records** for entities and value objects (Java 17+)
- **Sealed interfaces** for sum types
- **Enums** for simple enumerations
- **Optional<T>** for nullable fields
- **List<T>** for collections
- **Jackson annotations** for serialization

## Type Mappings

| SketchDDD | Java Type |
|-----------|-----------|
| `String` | `String` |
| `Int` | `long` |
| `Float` | `double` |
| `Bool` | `boolean` |
| `UUID` | `UUID` |
| `DateTime` | `Instant` |
| `Date` | `LocalDate` |
| `Decimal` | `BigDecimal` |
| `Email` | `String` |
| `List<T>` | `List<T>` |
| `Map<K,V>` | `Map<K, V>` |
| `T?` | `Optional<T>` |

## Example Output

### Input

```sddd
context Customers {
  entity Customer {
    id: UUID
    email: Email
    name: String
    phone: String?
    tier: CustomerTier
    createdAt: DateTime
    addresses: List<Address>
  }

  value Address {
    street: String
    city: String
    state: String
    zipCode: String
    country: String
  }

  enum CustomerTier = Bronze | Silver | Gold | Platinum
}
```

### Generated Code

```java
// Generated by SketchDDD
// Context: Customers

package domain.customers;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.*;
import com.fasterxml.jackson.annotation.*;

/**
 * CustomerTier enumeration
 */
public enum CustomerTier {
    Bronze,
    Silver,
    Gold,
    Platinum
}

/**
 * Address value object
 */
public record Address(
    String street,
    String city,
    String state,
    String zipCode,
    String country
) {}

/**
 * Customer entity
 */
public record Customer(
    UUID id,
    String email,
    String name,
    Optional<String> phone,
    CustomerTier tier,
    Instant createdAt,
    List<Address> addresses
) {
    public Customer {
        Objects.requireNonNull(id, "id must not be null");
        Objects.requireNonNull(email, "email must not be null");
        Objects.requireNonNull(name, "name must not be null");
        Objects.requireNonNull(tier, "tier must not be null");
        Objects.requireNonNull(createdAt, "createdAt must not be null");
        addresses = addresses != null ? List.copyOf(addresses) : List.of();
        phone = phone != null ? phone : Optional.empty();
    }
}
```

## Sum Types with Sealed Interfaces

For enums with associated data:

### Input

```sddd
context Notifications {
  enum NotificationChannel {
    Email { address: Email }
    SMS { phoneNumber: String }
    Push { deviceToken: String, platform: Platform }
    InApp
  }

  enum Platform = iOS | Android | Web
}
```

### Generated Code

```java
public enum Platform {
    iOS,
    Android,
    Web
}

public sealed interface NotificationChannel
    permits NotificationChannel.Email,
            NotificationChannel.SMS,
            NotificationChannel.Push,
            NotificationChannel.InApp {

    record Email(String address) implements NotificationChannel {}
    record SMS(String phoneNumber) implements NotificationChannel {}
    record Push(String deviceToken, Platform platform) implements NotificationChannel {}
    record InApp() implements NotificationChannel {}
}
```

## Usage Patterns

### With Spring Boot

```java
@RestController
@RequestMapping("/api/customers")
public class CustomerController {

    private final CustomerService customerService;

    public CustomerController(CustomerService customerService) {
        this.customerService = customerService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<Customer> getCustomer(@PathVariable UUID id) {
        return customerService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public Customer createCustomer(@RequestBody CreateCustomerRequest request) {
        return customerService.create(request);
    }
}
```

### Pattern Matching

```java
public String describeChannel(NotificationChannel channel) {
    return switch (channel) {
        case NotificationChannel.Email e ->
            "Email to " + e.address();
        case NotificationChannel.SMS s ->
            "SMS to " + s.phoneNumber();
        case NotificationChannel.Push p ->
            "Push to " + p.platform() + " device";
        case NotificationChannel.InApp i ->
            "In-app notification";
    };
}
```

### With JPA/Hibernate

```java
@Entity
@Table(name = "customers")
public class CustomerEntity {

    @Id
    private UUID id;

    @Column(nullable = false)
    private String email;

    @Column(nullable = false)
    private String name;

    private String phone;

    @Enumerated(EnumType.STRING)
    private CustomerTier tier;

    @Column(name = "created_at")
    private Instant createdAt;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<AddressEntity> addresses = new ArrayList<>();

    public Customer toDomain() {
        return new Customer(
            id,
            email,
            name,
            Optional.ofNullable(phone),
            tier,
            createdAt,
            addresses.stream()
                .map(AddressEntity::toDomain)
                .toList()
        );
    }
}
```

### With Builders

```java
public class CustomerBuilder {
    private UUID id;
    private String email;
    private String name;
    private Optional<String> phone = Optional.empty();
    private CustomerTier tier = CustomerTier.Bronze;
    private Instant createdAt = Instant.now();
    private List<Address> addresses = List.of();

    public CustomerBuilder id(UUID id) {
        this.id = id;
        return this;
    }

    public CustomerBuilder email(String email) {
        this.email = email;
        return this;
    }

    // ... other setters

    public Customer build() {
        return new Customer(id, email, name, phone, tier, createdAt, addresses);
    }
}
```

## Maven Dependencies

```xml
<dependencies>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.0</version>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.datatype</groupId>
        <artifactId>jackson-datatype-jdk8</artifactId>
        <version>2.15.0</version>
    </dependency>
</dependencies>
```

## Project Organization

```
src/main/java/
├── domain/
│   ├── customers/
│   │   └── Customer.java     # Generated
│   ├── orders/
│   │   └── Order.java        # Generated
│   └── products/
│       └── Product.java      # Generated
├── repository/
│   └── ...
└── service/
    └── ...
```

## Tips

### Adding Validation

```java
public record Customer(
    UUID id,
    String email,
    String name,
    Optional<String> phone,
    CustomerTier tier,
    Instant createdAt,
    List<Address> addresses
) {
    public Customer {
        Objects.requireNonNull(id);
        if (!email.matches("^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$")) {
            throw new IllegalArgumentException("Invalid email format");
        }
        if (name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be blank");
        }
    }
}
```

### Wither Methods

```java
public record Customer(...) {
    public Customer withTier(CustomerTier newTier) {
        return new Customer(id, email, name, phone, newTier, createdAt, addresses);
    }

    public Customer withAddress(Address address) {
        var newAddresses = new ArrayList<>(addresses);
        newAddresses.add(address);
        return new Customer(id, email, name, phone, tier, createdAt, List.copyOf(newAddresses));
    }
}
```
