# Clojure Code Generation

SketchDDD generates idiomatic Clojure code with specs and records.

## Generation

```bash
sketchddd codegen domain.sddd --target clojure --output ./src/domain
```

## Features

- **defrecord** for entities and value objects
- **clojure.spec.alpha** for validation
- **Keywords** for enum variants
- **Protocols** for domain behavior
- **Immutable by default**

## Type Mappings

| SketchDDD | Clojure Type / Spec |
|-----------|---------------------|
| `String` | `string?` |
| `Int` | `int?` |
| `Float` | `float?` |
| `Bool` | `boolean?` |
| `UUID` | `uuid?` |
| `DateTime` | `inst?` |
| `Date` | `inst?` |
| `Decimal` | `decimal?` |
| `Email` | `string?` (with regex) |
| `List<T>` | `(s/coll-of T)` |
| `Map<K,V>` | `(s/map-of K V)` |
| `T?` | `(s/nilable T)` |

## Example Output

### Input

```sddd
context Catalog {
  entity Product {
    id: UUID
    sku: String
    name: String
    description: String?
    price: Money
    category: Category
    tags: List<String>
  }

  value Money {
    amount: Decimal
    currency: Currency
  }

  enum Category = Electronics | Clothing | Books | Home
  enum Currency = USD | EUR | GBP
}
```

### Generated Code

```clojure
;; Generated by SketchDDD
;; Context: Catalog

(ns domain.catalog
  (:require [clojure.spec.alpha :as s]))

;; ============================================================
;; Enumerations
;; ============================================================

(def category-values #{:electronics :clothing :books :home})
(s/def ::category category-values)

(def currency-values #{:usd :eur :gbp})
(s/def ::currency currency-values)

;; ============================================================
;; Value Objects
;; ============================================================

(s/def ::amount decimal?)
(s/def ::money (s/keys :req-un [::amount ::currency]))

(defrecord Money [amount currency])

(defn make-money
  "Create a Money value object"
  [amount currency]
  {:pre [(s/valid? ::amount amount)
         (s/valid? ::currency currency)]}
  (->Money amount currency))

;; ============================================================
;; Entities
;; ============================================================

(s/def ::id uuid?)
(s/def ::sku string?)
(s/def ::name string?)
(s/def ::description (s/nilable string?))
(s/def ::price ::money)
(s/def ::tags (s/coll-of string?))

(s/def ::product
  (s/keys :req-un [::id ::sku ::name ::price ::category ::tags]
          :opt-un [::description]))

(defrecord Product [id sku name description price category tags])

(defn make-product
  "Create a Product entity"
  [{:keys [id sku name description price category tags]}]
  {:pre [(s/valid? ::product {:id id :sku sku :name name
                               :description description :price price
                               :category category :tags tags})]}
  (->Product id sku name description price category tags))
```

## Usage Patterns

### Creating Instances

```clojure
(require '[domain.catalog :as catalog])

;; Create a money value
(def price (catalog/make-money 29.99M :usd))

;; Create a product
(def product
  (catalog/make-product
    {:id (java.util.UUID/randomUUID)
     :sku "WIDGET-001"
     :name "Widget"
     :description "A useful widget"
     :price price
     :category :electronics
     :tags ["gadget" "useful"]}))
```

### With Component/Mount

```clojure
(ns app.components.product-repository
  (:require [domain.catalog :as catalog]
            [com.stuartsierra.component :as component]))

(defrecord ProductRepository [db]
  component/Lifecycle
  (start [this] this)
  (stop [this] this))

(defn find-by-id [repo id]
  (->> (jdbc/query (:db repo)
         ["SELECT * FROM products WHERE id = ?" id])
       first
       (catalog/make-product)))

(defn save! [repo product]
  (jdbc/insert! (:db repo) :products
    {:id (:id product)
     :sku (:sku product)
     :name (:name product)
     :description (:description product)
     :price_amount (:amount (:price product))
     :price_currency (name (:currency (:price product)))
     :category (name (:category product))
     :tags (pr-str (:tags product))}))
```

### With Ring/Compojure

```clojure
(ns app.handlers.products
  (:require [domain.catalog :as catalog]
            [ring.util.response :as response]
            [cheshire.core :as json]))

(defn get-product [repo id]
  (if-let [product (find-by-id repo (java.util.UUID/fromString id))]
    (response/response (json/generate-string product))
    (response/not-found "Product not found")))

(defn create-product [repo request]
  (let [body (json/parse-string (slurp (:body request)) true)
        product (catalog/make-product
                  (assoc body
                    :id (java.util.UUID/randomUUID)
                    :price (catalog/make-money
                             (bigdec (:amount (:price body)))
                             (keyword (:currency (:price body))))))]
    (save! repo product)
    (response/created (str "/products/" (:id product))
                      (json/generate-string product))))
```

### Validation

```clojure
(require '[clojure.spec.alpha :as s])

;; Validate data
(s/valid? ::catalog/product
  {:id (java.util.UUID/randomUUID)
   :sku "TEST-001"
   :name "Test Product"
   :price {:amount 10.00M :currency :usd}
   :category :electronics
   :tags []})
;; => true

;; Explain failures
(s/explain ::catalog/product
  {:id "not-a-uuid"
   :sku "TEST"
   :name "Test"
   :price {:amount "not-a-decimal" :currency :invalid}
   :category :unknown
   :tags []})
;; Prints detailed explanation of what's wrong
```

## Project Organization

```
src/
├── domain/
│   ├── catalog.clj      # Generated
│   ├── orders.clj       # Generated
│   └── customers.clj    # Generated
├── app/
│   ├── handlers/
│   ├── components/
│   └── core.clj
└── ...
```

## deps.edn Dependencies

```clojure
{:deps
 {org.clojure/clojure {:mvn/version "1.11.1"}
  org.clojure/spec.alpha {:mvn/version "0.3.218"}}}
```

## Tips

### Adding Protocols

```clojure
(defprotocol Priceable
  (total-price [this] "Calculate total price"))

(extend-protocol Priceable
  Product
  (total-price [this]
    (:price this)))
```

### Multimethods for Polymorphism

```clojure
(defmulti calculate-discount :category)

(defmethod calculate-discount :electronics [product]
  (update-in product [:price :amount] #(* % 0.9M)))

(defmethod calculate-discount :books [product]
  (update-in product [:price :amount] #(* % 0.85M)))

(defmethod calculate-discount :default [product]
  product)
```

### Transducers for Collections

```clojure
(defn expensive-electronics [products]
  (into []
    (comp
      (filter #(= :electronics (:category %)))
      (filter #(> (get-in % [:price :amount]) 100M))
      (map :name))
    products))
```
