# Python Code Generation

SketchDDD generates Python code using dataclasses with optional Pydantic support.

## Generation

```bash
# Standard dataclasses
sketchddd codegen domain.sddd --target python --output ./src/domain

# With Pydantic models
sketchddd codegen domain.sddd --target python --pydantic --output ./src/domain
```

## Features

- **Dataclasses** with frozen=True for immutability
- **Pydantic models** for validation (optional)
- **Type hints** with full typing module support
- **Enums** using Python's enum module
- **Optional types** with `| None` syntax
- **Generic collections** with list[] and dict[]

## Type Mappings

| SketchDDD | Python Type |
|-----------|-------------|
| `String` | `str` |
| `Int` | `int` |
| `Float` | `float` |
| `Bool` | `bool` |
| `UUID` | `UUID` |
| `DateTime` | `datetime` |
| `Date` | `date` |
| `Decimal` | `Decimal` |
| `Email` | `str` |
| `List<T>` | `list[T]` |
| `Map<K,V>` | `dict[K, V]` |
| `T?` | `T \| None` |

## Example Output

### Input

```sddd
context Inventory {
  entity Product {
    id: UUID
    sku: String
    name: String
    description: String?
    price: Money
    quantity: Int
    category: Category
    tags: List<String>
  }

  value Money {
    amount: Decimal
    currency: Currency
  }

  enum Category = Electronics | Clothing | Books | Home | Sports
  enum Currency = USD | EUR | GBP
}
```

### Generated Dataclasses

```python
# Generated by SketchDDD
# Context: Inventory

from dataclasses import dataclass
from decimal import Decimal
from datetime import datetime, date
from enum import Enum
from typing import Optional
from uuid import UUID


class Category(Enum):
    """Category enumeration"""
    ELECTRONICS = "Electronics"
    CLOTHING = "Clothing"
    BOOKS = "Books"
    HOME = "Home"
    SPORTS = "Sports"


class Currency(Enum):
    """Currency enumeration"""
    USD = "USD"
    EUR = "EUR"
    GBP = "GBP"


@dataclass(frozen=True)
class Money:
    """Money value object"""
    amount: Decimal
    currency: Currency


@dataclass(frozen=True)
class Product:
    """Product entity"""
    id: UUID
    sku: str
    name: str
    price: Money
    quantity: int
    category: Category
    tags: list[str]
    description: str | None = None
```

### Generated Pydantic Models

```python
# Generated by SketchDDD
# Context: Inventory

from decimal import Decimal
from datetime import datetime, date
from enum import Enum
from uuid import UUID
from pydantic import BaseModel, Field


class Category(str, Enum):
    """Category enumeration"""
    ELECTRONICS = "Electronics"
    CLOTHING = "Clothing"
    BOOKS = "Books"
    HOME = "Home"
    SPORTS = "Sports"


class Currency(str, Enum):
    """Currency enumeration"""
    USD = "USD"
    EUR = "EUR"
    GBP = "GBP"


class Money(BaseModel):
    """Money value object"""
    amount: Decimal
    currency: Currency

    class Config:
        frozen = True


class Product(BaseModel):
    """Product entity"""
    id: UUID
    sku: str
    name: str
    price: Money
    quantity: int
    category: Category
    tags: list[str]
    description: str | None = None

    class Config:
        frozen = True
```

## Usage Patterns

### With FastAPI

```python
from fastapi import FastAPI, HTTPException
from domain.inventory import Product, Category

app = FastAPI()

@app.get("/products/{product_id}")
async def get_product(product_id: UUID) -> Product:
    product = await product_repository.find_by_id(product_id)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    return product

@app.get("/products/")
async def list_products(category: Category | None = None) -> list[Product]:
    if category:
        return await product_repository.find_by_category(category)
    return await product_repository.find_all()
```

### With SQLAlchemy

```python
from sqlalchemy import Column, String, Integer, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from domain.inventory import Product, Category, Currency

class ProductModel(Base):
    __tablename__ = "products"

    id = Column(PGUUID, primary_key=True)
    sku = Column(String, unique=True, nullable=False)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)
    price_amount = Column(Integer, nullable=False)  # Store as cents
    price_currency = Column(SQLEnum(Currency), nullable=False)
    quantity = Column(Integer, nullable=False)
    category = Column(SQLEnum(Category), nullable=False)

    def to_domain(self) -> Product:
        return Product(
            id=self.id,
            sku=self.sku,
            name=self.name,
            description=self.description,
            price=Money(
                amount=Decimal(self.price_amount) / 100,
                currency=self.price_currency
            ),
            quantity=self.quantity,
            category=self.category,
            tags=[]  # Load separately
        )
```

### With Django

```python
from django.db import models
from domain.inventory import Category, Currency

class ProductModel(models.Model):
    id = models.UUIDField(primary_key=True)
    sku = models.CharField(max_length=100, unique=True)
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    price_amount = models.DecimalField(max_digits=10, decimal_places=2)
    price_currency = models.CharField(
        max_length=3,
        choices=[(c.value, c.value) for c in Currency]
    )
    quantity = models.IntegerField()
    category = models.CharField(
        max_length=20,
        choices=[(c.value, c.value) for c in Category]
    )
```

## Project Organization

```
src/
├── domain/
│   ├── __init__.py
│   ├── inventory.py    # Generated
│   ├── orders.py       # Generated
│   └── users.py        # Generated
├── repository/
│   └── ...
└── service/
    └── ...
```

## Tips

### Adding Methods

```python
@dataclass(frozen=True)
class Money:
    amount: Decimal
    currency: Currency

    def __add__(self, other: "Money") -> "Money":
        if self.currency != other.currency:
            raise ValueError("Currency mismatch")
        return Money(self.amount + other.amount, self.currency)

    def __mul__(self, factor: int) -> "Money":
        return Money(self.amount * factor, self.currency)
```

### Validation with Pydantic

```python
from pydantic import validator

class Money(BaseModel):
    amount: Decimal
    currency: Currency

    @validator('amount')
    def amount_must_be_positive(cls, v):
        if v < 0:
            raise ValueError('Amount must be positive')
        return v
```

### Type Aliases for IDs

```python
from typing import NewType

ProductId = NewType('ProductId', UUID)
OrderId = NewType('OrderId', UUID)
```
