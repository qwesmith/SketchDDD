# Haskell Code Generation

SketchDDD generates idiomatic Haskell code with algebraic data types and type classes.

## Generation

```bash
sketchddd codegen domain.sddd --target haskell --output ./src/Domain
```

## Features

- **Algebraic Data Types** for all domain types
- **Newtype wrappers** for value objects
- **Deriving clauses** for Show, Eq, Ord, Generic
- **Aeson instances** for JSON serialization
- **Maybe** for optional fields
- **Pattern matching** friendly structure

## Type Mappings

| SketchDDD | Haskell Type |
|-----------|--------------|
| `String` | `Text` |
| `Int` | `Int64` |
| `Float` | `Double` |
| `Bool` | `Bool` |
| `UUID` | `UUID` |
| `DateTime` | `UTCTime` |
| `Date` | `Day` |
| `Decimal` | `Scientific` |
| `Email` | `Text` |
| `List<T>` | `[T]` |
| `Map<K,V>` | `Map K V` |
| `T?` | `Maybe T` |

## Example Output

### Input

```sddd
context Library {
  entity Book {
    id: UUID
    isbn: String
    title: String
    author: String
    synopsis: String?
    price: Money
    genre: Genre
    tags: List<String>
  }

  value Money {
    amount: Decimal
    currency: Currency
  }

  enum Genre = Fiction | NonFiction | Science | History | Biography
  enum Currency = USD | EUR | GBP
}
```

### Generated Code

```haskell
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE OverloadedStrings #-}

-- | Generated by SketchDDD
-- | Context: Library

module Domain.Library
  ( -- * Enumerations
    Genre(..)
  , Currency(..)
    -- * Value Objects
  , Money(..)
    -- * Entities
  , Book(..)
  ) where

import Data.Aeson (FromJSON, ToJSON)
import Data.Int (Int64)
import Data.Map (Map)
import Data.Maybe (Maybe)
import Data.Scientific (Scientific)
import Data.Text (Text)
import Data.Time (Day, UTCTime)
import Data.UUID (UUID)
import GHC.Generics (Generic)

-- ============================================================
-- Enumerations
-- ============================================================

-- | Genre enumeration
data Genre
  = Fiction
  | NonFiction
  | Science
  | History
  | Biography
  deriving (Show, Eq, Ord, Generic, FromJSON, ToJSON)

-- | Currency enumeration
data Currency
  = USD
  | EUR
  | GBP
  deriving (Show, Eq, Ord, Generic, FromJSON, ToJSON)

-- ============================================================
-- Value Objects
-- ============================================================

-- | Money value object
data Money = Money
  { moneyAmount :: Scientific
  , moneyCurrency :: Currency
  } deriving (Show, Eq, Ord, Generic, FromJSON, ToJSON)

-- ============================================================
-- Entities
-- ============================================================

-- | Book entity
data Book = Book
  { bookId :: UUID
  , bookIsbn :: Text
  , bookTitle :: Text
  , bookAuthor :: Text
  , bookSynopsis :: Maybe Text
  , bookPrice :: Money
  , bookGenre :: Genre
  , bookTags :: [Text]
  } deriving (Show, Eq, Generic, FromJSON, ToJSON)
```

## Sum Types

For enums with associated data:

### Input

```sddd
context Payments {
  enum PaymentMethod {
    CreditCard { last4: String, brand: CardBrand }
    BankTransfer { bankName: String, accountLast4: String }
    Wallet { provider: WalletProvider }
    Cash
  }

  enum CardBrand = Visa | Mastercard | Amex
  enum WalletProvider = PayPal | ApplePay | GooglePay
}
```

### Generated Code

```haskell
data CardBrand = Visa | Mastercard | Amex
  deriving (Show, Eq, Ord, Generic, FromJSON, ToJSON)

data WalletProvider = PayPal | ApplePay | GooglePay
  deriving (Show, Eq, Ord, Generic, FromJSON, ToJSON)

data PaymentMethod
  = CreditCard { creditCardLast4 :: Text, creditCardBrand :: CardBrand }
  | BankTransfer { bankTransferBankName :: Text, bankTransferAccountLast4 :: Text }
  | Wallet { walletProvider :: WalletProvider }
  | Cash
  deriving (Show, Eq, Generic, FromJSON, ToJSON)
```

## Usage Patterns

### Pattern Matching

```haskell
describePayment :: PaymentMethod -> Text
describePayment method = case method of
  CreditCard last4 brand ->
    "Credit card ending in " <> last4 <> " (" <> show brand <> ")"
  BankTransfer bankName _ ->
    "Bank transfer from " <> bankName
  Wallet provider ->
    "Digital wallet: " <> show provider
  Cash ->
    "Cash payment"
```

### With Servant

```haskell
type BookAPI =
       "books" :> Get '[JSON] [Book]
  :<|> "books" :> Capture "id" UUID :> Get '[JSON] Book
  :<|> "books" :> ReqBody '[JSON] CreateBookRequest :> Post '[JSON] Book

server :: Server BookAPI
server = listBooks :<|> getBook :<|> createBook
  where
    listBooks :: Handler [Book]
    listBooks = liftIO $ runQuery selectAllBooks

    getBook :: UUID -> Handler Book
    getBook bookId = do
      maybeBook <- liftIO $ runQuery (selectBookById bookId)
      case maybeBook of
        Just book -> return book
        Nothing   -> throwError err404

    createBook :: CreateBookRequest -> Handler Book
    createBook req = liftIO $ runQuery (insertBook req)
```

### With Persistent

```haskell
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
BookEntity
    uuid UUID
    isbn Text
    title Text
    author Text
    synopsis Text Maybe
    priceAmount Scientific
    priceCurrency Currency
    genre Genre
    UniqueIsbn isbn
    deriving Show
|]

toDomain :: Entity BookEntity -> Book
toDomain (Entity _ e) = Book
  { bookId = bookEntityUuid e
  , bookIsbn = bookEntityIsbn e
  , bookTitle = bookEntityTitle e
  , bookAuthor = bookEntityAuthor e
  , bookSynopsis = bookEntitySynopsis e
  , bookPrice = Money (bookEntityPriceAmount e) (bookEntityPriceCurrency e)
  , bookGenre = bookEntityGenre e
  , bookTags = []  -- Load separately
  }
```

### Smart Constructors

```haskell
module Domain.Library
  ( Money  -- Export type but not constructor
  , mkMoney
  , getAmount
  , getCurrency
  ) where

newtype Money = Money { unMoney :: (Scientific, Currency) }
  deriving (Show, Eq, Generic)

mkMoney :: Scientific -> Currency -> Either Text Money
mkMoney amount currency
  | amount < 0 = Left "Amount cannot be negative"
  | otherwise  = Right $ Money (amount, currency)

getAmount :: Money -> Scientific
getAmount = fst . unMoney

getCurrency :: Money -> Currency
getCurrency = snd . unMoney
```

## Cabal Dependencies

```cabal
build-depends:
    base >= 4.14 && < 5
  , aeson >= 2.0
  , containers
  , scientific
  , text
  , time
  , uuid
```

## Project Organization

```
src/
├── Domain/
│   ├── Library.hs      # Generated
│   ├── Orders.hs       # Generated
│   └── Customers.hs    # Generated
├── Repository/
│   └── ...
├── Service/
│   └── ...
└── Main.hs
```

## Tips

### Lenses

```haskell
{-# LANGUAGE TemplateHaskell #-}

import Control.Lens

makeLenses ''Book
makeLenses ''Money

-- Usage
updatePrice :: Book -> Scientific -> Book
updatePrice book newAmount =
  book & price . amount .~ newAmount
```

### Type Classes

```haskell
class HasPrice a where
  getPrice :: a -> Money

instance HasPrice Book where
  getPrice = bookPrice

totalPrice :: HasPrice a => [a] -> Money
totalPrice items =
  Money (sum $ map (moneyAmount . getPrice) items) USD
```

### Validation with Either

```haskell
data ValidationError
  = EmptyTitle
  | InvalidISBN
  | NegativePrice
  deriving (Show, Eq)

validateBook :: Book -> Either [ValidationError] Book
validateBook book = do
  let errors = catMaybes
        [ if T.null (bookTitle book) then Just EmptyTitle else Nothing
        , if not (validISBN $ bookIsbn book) then Just InvalidISBN else Nothing
        , if moneyAmount (bookPrice book) < 0 then Just NegativePrice else Nothing
        ]
  if null errors
    then Right book
    else Left errors
```
