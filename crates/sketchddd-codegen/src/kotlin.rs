//! Kotlin code generation for SketchDDD domain models.
//!
//! Generates idiomatic Kotlin code from a bounded context:
//! - Entities as data classes with inline value class IDs
//! - Value objects as immutable data classes
//! - Aggregates with validation methods
//! - Sealed classes/interfaces for sum types
//! - kotlinx.serialization annotations

use crate::CodegenError;
use sketchddd_core::sketch::{ColimitCocone, LimitCone, Morphism, ObjectId};
use sketchddd_core::BoundedContext;
use std::collections::{HashMap, HashSet};

/// Configuration options for Kotlin code generation.
#[derive(Debug, Clone)]
pub struct KotlinConfig {
    /// Package name (defaults to context name in lowercase)
    pub package_name: Option<String>,
    /// Whether to use kotlinx.serialization annotations
    pub use_serialization: bool,
    /// Whether to use Arrow-kt for functional types
    pub use_arrow: bool,
    /// Whether to generate companion object factories
    pub generate_factories: bool,
    /// Whether to generate validation methods
    pub generate_validation: bool,
}

impl Default for KotlinConfig {
    fn default() -> Self {
        Self {
            package_name: None,
            use_serialization: true,
            use_arrow: false,
            generate_factories: true,
            generate_validation: true,
        }
    }
}

/// Generate Kotlin code from a bounded context with default configuration.
pub fn generate(context: &BoundedContext) -> Result<String, CodegenError> {
    generate_with_config(context, &KotlinConfig::default())
}

/// Generate Kotlin code from a bounded context with custom configuration.
pub fn generate_with_config(
    context: &BoundedContext,
    config: &KotlinConfig,
) -> Result<String, CodegenError> {
    let mut gen = KotlinGenerator::new(context, config);
    gen.generate()
}

/// Internal generator state.
struct KotlinGenerator<'a> {
    context: &'a BoundedContext,
    config: &'a KotlinConfig,
    output: String,
    entity_ids: HashSet<ObjectId>,
    value_object_ids: HashSet<ObjectId>,
    aggregate_roots: HashSet<ObjectId>,
    object_names: HashMap<ObjectId, String>,
    object_morphisms: HashMap<ObjectId, Vec<&'a Morphism>>,
}

impl<'a> KotlinGenerator<'a> {
    fn new(context: &'a BoundedContext, config: &'a KotlinConfig) -> Self {
        let entity_ids: HashSet<_> = context.entities().iter().copied().collect();
        let value_object_ids: HashSet<_> = context.value_objects().iter().copied().collect();
        let aggregate_roots: HashSet<_> = context.aggregate_roots().iter().copied().collect();

        let object_names: HashMap<_, _> = context
            .graph()
            .objects()
            .map(|o| (o.id, o.name.clone()))
            .collect();

        let mut object_morphisms: HashMap<ObjectId, Vec<&Morphism>> = HashMap::new();
        for morphism in context.graph().morphisms() {
            if !morphism.is_identity {
                object_morphisms
                    .entry(morphism.source)
                    .or_default()
                    .push(morphism);
            }
        }

        Self {
            context,
            config,
            output: String::new(),
            entity_ids,
            value_object_ids,
            aggregate_roots,
            object_names,
            object_morphisms,
        }
    }

    fn generate(&mut self) -> Result<String, CodegenError> {
        self.write_header();
        self.write_imports();
        self.write_entities();
        self.write_value_objects();
        self.write_enums();
        self.write_aggregates();

        Ok(std::mem::take(&mut self.output))
    }

    fn write_header(&mut self) {
        let package_name = self
            .config
            .package_name
            .clone()
            .unwrap_or_else(|| to_package_name(self.context.name()));

        self.output.push_str(&format!(
            r#"/**
 * Generated from `{}` bounded context.
 *
 * This file was automatically generated by SketchDDD.
 * DO NOT EDIT - changes will be overwritten.
 *
 * To regenerate: `sketchddd codegen <model>.sddd --target kotlin`
 */

@file:Suppress("unused")

package {}

"#,
            self.context.name(),
            package_name
        ));
    }

    fn write_imports(&mut self) {
        self.output.push_str("import java.util.UUID\n");

        if self.config.use_serialization {
            self.output.push_str("import kotlinx.serialization.Serializable\n");
            self.output.push_str("import kotlinx.serialization.KSerializer\n");
            self.output.push_str("import kotlinx.serialization.descriptors.*\n");
            self.output.push_str("import kotlinx.serialization.encoding.*\n");
        }

        if self.config.use_arrow {
            self.output.push_str("import arrow.core.Either\n");
            self.output.push_str("import arrow.core.left\n");
            self.output.push_str("import arrow.core.right\n");
        }

        self.output.push_str("\n");
    }

    fn write_entities(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Entities\n");
        self.output.push_str("// =============================================================\n\n");

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                self.write_entity_id_type(&entity.name);
                self.write_entity_class(&entity.name, *entity_id);
            }
        }
    }

    fn write_entity_id_type(&mut self, name: &str) {
        let serializable = if self.config.use_serialization {
            "@Serializable(with = ${name}Id.Serializer::class)\n"
                .replace("${name}", name)
        } else {
            String::new()
        };

        self.output.push_str(&format!(
            r#"/**
 * Unique identifier for [{name}].
 *
 * Uses inline value class for zero-overhead type safety.
 */
{serializable}@JvmInline
value class {name}Id(val value: UUID) {{
    override fun toString(): String = value.toString()

    companion object {{
        /** Create a new random ID. */
        fun create(): {name}Id = {name}Id(UUID.randomUUID())

        /** Create from an existing UUID. */
        fun fromUUID(uuid: UUID): {name}Id = {name}Id(uuid)

        /** Parse from a string representation. */
        fun fromString(s: String): {name}Id = {name}Id(UUID.fromString(s))
    }}
"#
        ));

        // Add serializer if using kotlinx.serialization
        if self.config.use_serialization {
            self.output.push_str(&format!(
                r#"
    object Serializer : KSerializer<{name}Id> {{
        override val descriptor: SerialDescriptor =
            PrimitiveSerialDescriptor("{name}Id", PrimitiveKind.STRING)

        override fun serialize(encoder: Encoder, value: {name}Id) {{
            encoder.encodeString(value.value.toString())
        }}

        override fun deserialize(decoder: Decoder): {name}Id {{
            return {name}Id(UUID.fromString(decoder.decodeString()))
        }}
    }}
"#
            ));
        }

        self.output.push_str("}\n\n");
    }

    fn write_entity_class(&mut self, name: &str, object_id: ObjectId) {
        let serializable = if self.config.use_serialization {
            "@Serializable\n"
        } else {
            ""
        };

        let is_aggregate_root = self.aggregate_roots.contains(&object_id);
        let root_note = if is_aggregate_root {
            " (Aggregate Root)"
        } else {
            ""
        };

        self.output.push_str(&format!(
            r#"/**
 * Entity: {name}{root_note}
 *
 * An entity has a unique identity that persists through state changes.
 */
{serializable}data class {name}(
    /** Unique identifier */
    val id: {name}Id,
"#
        ));

        // Add fields from morphisms
        let field_strs: Vec<String> = self
            .object_morphisms
            .get(&object_id)
            .map(|morphisms| {
                morphisms
                    .iter()
                    .map(|m| self.format_field(m))
                    .collect()
            })
            .unwrap_or_default();

        for (i, field_str) in field_strs.iter().enumerate() {
            self.output.push_str(field_str);
            if i < field_strs.len() - 1 {
                self.output.push_str(",\n");
            } else {
                self.output.push('\n');
            }
        }

        // Close the data class, removing trailing comma if no fields
        if field_strs.is_empty() {
            // Remove the trailing comma after id
            self.output = self.output.trim_end().trim_end_matches(',').to_string();
            self.output.push('\n');
        }

        self.output.push_str(")");

        // Add companion object with factory
        if self.config.generate_factories {
            self.output.push_str(" {\n");
            self.output.push_str("    companion object {\n");
            self.output.push_str(&format!(
                "        /** Create a new {name} with a generated ID. */\n"
            ));
            self.output.push_str(&format!("        fun create("));

            // Parameters
            if let Some(morphisms) = self.object_morphisms.get(&object_id) {
                let params: Vec<String> = morphisms
                    .iter()
                    .map(|m| format!("{}: {}", to_camel_case(&m.name), self.kotlin_type_for_target(m.target)))
                    .collect();
                self.output.push_str(&params.join(", "));
            }

            self.output.push_str(&format!("): {name} = {name}(\n"));
            self.output.push_str(&format!("            id = {name}Id.create(),\n"));

            if let Some(morphisms) = self.object_morphisms.get(&object_id) {
                for morphism in morphisms {
                    let field_name = to_camel_case(&morphism.name);
                    self.output.push_str(&format!("            {field_name} = {field_name},\n"));
                }
            }

            self.output.push_str("        )\n");
            self.output.push_str("    }\n");
            self.output.push_str("}\n\n");
        } else {
            self.output.push_str("\n\n");
        }
    }

    fn write_value_objects(&mut self) {
        if self.value_object_ids.is_empty() {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Value Objects\n");
        self.output.push_str("// =============================================================\n\n");

        for vo_id in self.context.value_objects() {
            if let Some(vo) = self.context.graph().get_object(*vo_id) {
                self.write_value_object(&vo.name, *vo_id);
            }
        }
    }

    fn write_value_object(&mut self, name: &str, object_id: ObjectId) {
        let serializable = if self.config.use_serialization {
            "@Serializable\n"
        } else {
            ""
        };

        let limit_cone = self.context.get_value_object_limit(object_id);

        self.output.push_str(&format!(
            r#"/**
 * Value Object: {name}
 *
 * A value object is defined by its attributes, not identity.
 * Two value objects with the same attributes are considered equal.
 */
{serializable}data class {name}(
"#
        ));

        // Add fields from morphisms or projections
        let field_strs: Vec<String> = if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            morphisms.iter().map(|m| self.format_field(m)).collect()
        } else if let Some(cone) = limit_cone {
            cone.projections
                .iter()
                .filter_map(|proj| self.context.graph().get_morphism(proj.morphism))
                .map(|m| self.format_field(m))
                .collect()
        } else {
            Vec::new()
        };

        for (i, field_str) in field_strs.iter().enumerate() {
            self.output.push_str(field_str);
            if i < field_strs.len() - 1 {
                self.output.push_str(",\n");
            } else {
                self.output.push('\n');
            }
        }

        self.output.push_str(")\n\n");
    }

    fn write_enums(&mut self) {
        let colimits = &self.context.sketch().colimits;
        if colimits.is_empty() {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Enumerations (Sum Types)\n");
        self.output.push_str("// =============================================================\n\n");

        for colimit in colimits {
            self.write_enum(colimit);
        }
    }

    fn write_enum(&mut self, colimit: &ColimitCocone) {
        let serializable = if self.config.use_serialization {
            "@Serializable\n"
        } else {
            ""
        };

        // Check if this is a simple enum or a sum type with payloads
        let is_simple_enum = colimit.injections.iter().all(|i| i.source == colimit.apex);

        if is_simple_enum {
            // Generate Kotlin enum class
            self.output.push_str(&format!(
                r#"/**
 * Enumeration: {}
 *
 * A simple enumeration of possible values.
 */
{}enum class {} {{
"#,
                colimit.name, serializable, colimit.name
            ));

            for (i, injection) in colimit.injections.iter().enumerate() {
                if i < colimit.injections.len() - 1 {
                    self.output.push_str(&format!("    {},\n", injection.name));
                } else {
                    self.output.push_str(&format!("    {}\n", injection.name));
                }
            }

            self.output.push_str("}\n\n");
        } else {
            // Generate sealed class/interface for sum type
            self.output.push_str(&format!(
                r#"/**
 * Sum Type: {}
 *
 * A sealed hierarchy representing one of several possible variants.
 */
{}sealed interface {} {{
"#,
                colimit.name, serializable, colimit.name
            ));

            // Generate data class for each variant
            for injection in &colimit.injections {
                let variant_type = self
                    .object_names
                    .get(&injection.source)
                    .cloned()
                    .unwrap_or_else(|| "Any".to_string());

                let variant_serializable = if self.config.use_serialization {
                    "@Serializable "
                } else {
                    ""
                };

                self.output.push_str(&format!(
                    "    {}data class {}(val value: {}) : {}\n",
                    variant_serializable, injection.name, variant_type, colimit.name
                ));
            }

            self.output.push_str("}\n\n");

            // Generate extension functions for pattern matching
            self.write_sum_type_extensions(colimit);
        }
    }

    fn write_sum_type_extensions(&mut self, colimit: &ColimitCocone) {
        for injection in &colimit.injections {
            let fn_name = format!("is{}", injection.name);
            self.output.push_str(&format!(
                r#"/** Check if this is the {} variant. */
fun {}.{}(): Boolean = this is {}.{}

"#,
                injection.name, colimit.name, fn_name, colimit.name, injection.name
            ));
        }
    }

    fn write_aggregates(&mut self) {
        let limits: Vec<_> = self
            .context
            .sketch()
            .limits
            .iter()
            .filter(|l| l.is_aggregate)
            .collect();

        if limits.is_empty() || !self.config.generate_validation {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Aggregate Validation\n");
        self.output.push_str("// =============================================================\n\n");

        self.write_validation_error();

        for limit in limits {
            self.write_aggregate_validation(limit);
        }
    }

    fn write_validation_error(&mut self) {
        let serializable = if self.config.use_serialization {
            "@Serializable\n"
        } else {
            ""
        };

        self.output.push_str(&format!(
            r#"/**
 * Error returned when aggregate validation fails.
 */
{serializable}data class ValidationError(
    /** The invariant that was violated. */
    val invariant: String,
    /** Human-readable error message. */
    val message: String
)

/**
 * Result type for validation operations.
 */
sealed interface ValidationResult<out T> {{
    data class Success<T>(val value: T) : ValidationResult<T>
    data class Failure(val errors: List<ValidationError>) : ValidationResult<Nothing>
}}

/** Create a successful validation result. */
fun <T> validationSuccess(value: T): ValidationResult<T> = ValidationResult.Success(value)

/** Create a failed validation result. */
fun validationFailure(errors: List<ValidationError>): ValidationResult<Nothing> = ValidationResult.Failure(errors)

/** Create a failed validation result from a single error. */
fun validationFailure(invariant: String, message: String): ValidationResult<Nothing> =
    ValidationResult.Failure(listOf(ValidationError(invariant, message)))

"#
        ));
    }

    fn write_aggregate_validation(&mut self, limit: &LimitCone) {
        let root_id = match limit.root {
            Some(id) => id,
            None => return,
        };

        let root_name = self
            .object_names
            .get(&root_id)
            .cloned()
            .unwrap_or_else(|| "Unknown".to_string());

        let member_names: Vec<String> = limit
            .projections
            .iter()
            .filter_map(|p| self.object_names.get(&p.target).cloned())
            .collect();

        self.output.push_str(&format!(
            r#"/**
 * Aggregate: {}
 *
 * Root: [{}]
 * Members: {:?}
 */

/**
 * Validate {} aggregate invariants.
 *
 * Call this function after making changes to ensure the aggregate
 * is in a valid state.
 */
fun {}.validate(): ValidationResult<{}> {{
    val errors = mutableListOf<ValidationError>()

    // TODO: Add invariant validation logic based on model equations
    //
    // Example invariant:
    // if (totalPrice != items.sumOf {{ it.price }}) {{
    //     errors.add(ValidationError(
    //         invariant = "totalPrice",
    //         message = "totalPrice must equal sum of item prices"
    //     ))
    // }}

    return if (errors.isEmpty()) {{
        validationSuccess(this)
    }} else {{
        validationFailure(errors)
    }}
}}

/** Validate and return this entity, throwing on failure. */
fun {}.validateOrThrow(): {} {{
    return when (val result = validate()) {{
        is ValidationResult.Success -> result.value
        is ValidationResult.Failure -> throw IllegalStateException(
            "Validation failed: ${{result.errors.joinToString {{ "${{it.invariant}}: ${{it.message}}" }}}}"
        )
    }}
}}

"#,
            limit.name,
            root_name,
            member_names,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name
        ));
    }

    fn format_field(&self, morphism: &Morphism) -> String {
        let field_name = to_camel_case(&morphism.name);
        let field_type = self.kotlin_type_for_target(morphism.target);

        let mut result = String::new();
        if let Some(desc) = &morphism.description {
            result.push_str(&format!("    /** {} */\n", desc));
        }
        result.push_str(&format!("    val {}: {}", field_name, field_type));
        result
    }

    fn kotlin_type_for_target(&self, target: ObjectId) -> String {
        let target_name = self
            .object_names
            .get(&target)
            .cloned()
            .unwrap_or_else(|| "Any".to_string());

        if self.entity_ids.contains(&target) {
            format!("{}Id", target_name)
        } else {
            target_name
        }
    }
}

/// Convert to Kotlin package name (lowercase, dots allowed).
fn to_package_name(s: &str) -> String {
    s.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.')
        .collect::<String>()
        .to_lowercase()
}

/// Convert PascalCase or snake_case to camelCase.
fn to_camel_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = false;

    for (i, c) in s.chars().enumerate() {
        if c == '_' {
            capitalize_next = true;
        } else if i == 0 {
            result.push(c.to_ascii_lowercase());
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else if c.is_uppercase() && i > 0 {
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("Customer"), "customer");
        assert_eq!(to_camel_case("line_item"), "lineItem");
        assert_eq!(to_camel_case("placed_by"), "placedBy");
    }

    #[test]
    fn test_to_package_name() {
        assert_eq!(to_package_name("Commerce"), "commerce");
        assert_eq!(to_package_name("My Domain"), "mydomain");
    }

    #[test]
    fn test_generate_empty_context() {
        let context = BoundedContext::new("Test");
        let result = generate(&context).unwrap();

        assert!(result.contains("Generated from `Test` bounded context"));
        assert!(result.contains("package test"));
        assert!(result.contains("import java.util.UUID"));
    }

    #[test]
    fn test_generate_entity() {
        let mut context = BoundedContext::new("Commerce");
        let _customer = context.add_entity("Customer");

        let result = generate(&context).unwrap();

        // Should have inline value class for ID
        assert!(result.contains("@JvmInline"));
        assert!(result.contains("value class CustomerId(val value: UUID)"));

        // Should have entity data class
        assert!(result.contains("data class Customer("));
        assert!(result.contains("val id: CustomerId"));

        // Should have factory method
        assert!(result.contains("fun create("));
    }

    #[test]
    fn test_generate_entity_with_morphisms() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("placed_by", order, customer);

        let result = generate(&context).unwrap();

        // Order should have a placedBy field referencing CustomerId
        assert!(result.contains("data class Order("));
        assert!(result.contains("val placedBy: CustomerId"));
    }

    #[test]
    fn test_generate_value_object() {
        let mut context = BoundedContext::new("Commerce");
        let _money = context.add_value_object("Money");

        let result = generate(&context).unwrap();

        assert!(result.contains("// Value Objects"));
        assert!(result.contains("data class Money("));
    }

    #[test]
    fn test_generate_simple_enum() {
        let mut context = BoundedContext::new("Commerce");
        let _status = context.add_enum(
            "OrderStatus",
            vec!["Pending".into(), "Confirmed".into(), "Shipped".into()],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("enum class OrderStatus {"));
        assert!(result.contains("Pending,"));
        assert!(result.contains("Confirmed,"));
        assert!(result.contains("Shipped"));
    }

    #[test]
    fn test_generate_aggregate() {
        let mut context = BoundedContext::new("Commerce");
        let order = context.add_entity("Order");
        let line_item = context.add_entity("LineItem");

        context.define_aggregate_with_members("OrderAggregate", order, &[line_item]);

        let result = generate(&context).unwrap();

        assert!(result.contains("// Aggregate Validation"));
        assert!(result.contains("data class ValidationError("));
        assert!(result.contains("fun Order.validate(): ValidationResult<Order>"));
        assert!(result.contains("fun Order.validateOrThrow(): Order"));
    }

    #[test]
    fn test_generate_sum_type() {
        let mut context = BoundedContext::new("Payments");

        let transaction_id = context.sketch_mut().add_object("TransactionId");
        let error_code = context.sketch_mut().add_object("ErrorCode");

        let _result = context.add_sum_type(
            "PaymentResult",
            vec![
                ("Success".into(), transaction_id),
                ("Failed".into(), error_code),
            ],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("sealed interface PaymentResult {"));
        assert!(result.contains("data class Success(val value: TransactionId) : PaymentResult"));
        assert!(result.contains("data class Failed(val value: ErrorCode) : PaymentResult"));
        assert!(result.contains("fun PaymentResult.isSuccess(): Boolean"));
        assert!(result.contains("fun PaymentResult.isFailed(): Boolean"));
    }

    #[test]
    fn test_config_no_serialization() {
        let mut context = BoundedContext::new("Test");
        let _customer = context.add_entity("Customer");

        let config = KotlinConfig {
            use_serialization: false,
            ..Default::default()
        };

        let result = generate_with_config(&context, &config).unwrap();

        assert!(!result.contains("@Serializable"));
        assert!(!result.contains("import kotlinx.serialization"));
    }

    #[test]
    fn test_entity_references_use_id_type() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("customer", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("val customer: CustomerId"));
    }

    #[test]
    fn test_generate_commerce_domain() {
        let mut context = BoundedContext::new("Commerce");

        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");
        let product = context.add_entity("Product");
        let money = context.add_value_object("Money");

        context.sketch_mut().graph.add_morphism("placedBy", order, customer);
        context.sketch_mut().graph.add_morphism("price", product, money);

        let _status = context.add_enum(
            "OrderStatus",
            vec!["Pending".into(), "Confirmed".into(), "Shipped".into()],
        );

        context.define_aggregate("OrderAggregate", order);

        let result = generate(&context).unwrap();

        assert!(result.contains("value class CustomerId"));
        assert!(result.contains("value class OrderId"));
        assert!(result.contains("value class ProductId"));
        assert!(result.contains("data class Money("));
        assert!(result.contains("enum class OrderStatus"));
        assert!(result.contains("fun Order.validate()"));
    }
}
