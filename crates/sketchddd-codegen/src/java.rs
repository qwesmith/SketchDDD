//! Java code generation for SketchDDD domain models.
//!
//! Generates idiomatic Java code from a bounded context:
//! - Entities as records (Java 17+) or classes with Builder pattern
//! - Value objects as immutable records
//! - Aggregates with validation methods
//! - Enums for sum types
//! - Optional Jakarta/Javax validation annotations

use crate::CodegenError;
use sketchddd_core::sketch::{ColimitCocone, LimitCone, Morphism, ObjectId};
use sketchddd_core::BoundedContext;
use std::collections::{HashMap, HashSet};

/// Configuration options for Java code generation.
#[derive(Debug, Clone)]
pub struct JavaConfig {
    /// Package name (defaults to context name in lowercase)
    pub package_name: Option<String>,
    /// Whether to use Java records (requires Java 17+)
    pub use_records: bool,
    /// Whether to generate Jakarta validation annotations
    pub use_jakarta_validation: bool,
    /// Whether to generate Jackson annotations for JSON
    pub use_jackson: bool,
    /// Whether to generate Lombok annotations (if not using records)
    pub use_lombok: bool,
    /// Whether to generate validation methods
    pub generate_validation: bool,
    /// Whether to generate builder pattern (if not using records/lombok)
    pub generate_builders: bool,
}

impl Default for JavaConfig {
    fn default() -> Self {
        Self {
            package_name: None,
            use_records: true,
            use_jakarta_validation: false,
            use_jackson: true,
            use_lombok: false,
            generate_validation: true,
            generate_builders: false,
        }
    }
}

/// Generate Java code from a bounded context with default configuration.
pub fn generate(context: &BoundedContext) -> Result<String, CodegenError> {
    generate_with_config(context, &JavaConfig::default())
}

/// Generate Java code from a bounded context with custom configuration.
pub fn generate_with_config(
    context: &BoundedContext,
    config: &JavaConfig,
) -> Result<String, CodegenError> {
    let mut gen = JavaGenerator::new(context, config);
    gen.generate()
}

/// Internal generator state.
struct JavaGenerator<'a> {
    context: &'a BoundedContext,
    config: &'a JavaConfig,
    output: String,
    entity_ids: HashSet<ObjectId>,
    value_object_ids: HashSet<ObjectId>,
    aggregate_roots: HashSet<ObjectId>,
    object_names: HashMap<ObjectId, String>,
    object_morphisms: HashMap<ObjectId, Vec<&'a Morphism>>,
}

impl<'a> JavaGenerator<'a> {
    fn new(context: &'a BoundedContext, config: &'a JavaConfig) -> Self {
        let entity_ids: HashSet<_> = context.entities().iter().copied().collect();
        let value_object_ids: HashSet<_> = context.value_objects().iter().copied().collect();
        let aggregate_roots: HashSet<_> = context.aggregate_roots().iter().copied().collect();

        let object_names: HashMap<_, _> = context
            .graph()
            .objects()
            .map(|o| (o.id, o.name.clone()))
            .collect();

        let mut object_morphisms: HashMap<ObjectId, Vec<&Morphism>> = HashMap::new();
        for morphism in context.graph().morphisms() {
            if !morphism.is_identity {
                object_morphisms
                    .entry(morphism.source)
                    .or_default()
                    .push(morphism);
            }
        }

        Self {
            context,
            config,
            output: String::new(),
            entity_ids,
            value_object_ids,
            aggregate_roots,
            object_names,
            object_morphisms,
        }
    }

    fn generate(&mut self) -> Result<String, CodegenError> {
        self.write_header();
        self.write_imports();
        self.write_entities();
        self.write_value_objects();
        self.write_enums();
        self.write_aggregates();

        Ok(std::mem::take(&mut self.output))
    }

    fn write_header(&mut self) {
        let package_name = self
            .config
            .package_name
            .clone()
            .unwrap_or_else(|| to_package_name(self.context.name()));

        self.output.push_str(&format!(
            r#"/**
 * Generated from `{}` bounded context.
 *
 * This file was automatically generated by SketchDDD.
 * DO NOT EDIT - changes will be overwritten.
 *
 * To regenerate: sketchddd codegen model.sddd --target java
 */

package {};

"#,
            self.context.name(),
            package_name
        ));
    }

    fn write_imports(&mut self) {
        self.output.push_str("import java.util.UUID;\n");
        self.output.push_str("import java.util.Objects;\n");
        self.output.push_str("import java.util.List;\n");
        self.output.push_str("import java.util.ArrayList;\n");

        if self.config.use_jackson {
            self.output.push_str("import com.fasterxml.jackson.annotation.JsonCreator;\n");
            self.output.push_str("import com.fasterxml.jackson.annotation.JsonProperty;\n");
            self.output.push_str("import com.fasterxml.jackson.annotation.JsonValue;\n");
        }

        if self.config.use_jakarta_validation {
            self.output.push_str("import jakarta.validation.constraints.NotNull;\n");
            self.output.push_str("import jakarta.validation.Valid;\n");
        }

        if self.config.use_lombok {
            self.output.push_str("import lombok.Builder;\n");
            self.output.push_str("import lombok.Data;\n");
            self.output.push_str("import lombok.Value;\n");
        }

        self.output.push_str("\n");
    }

    fn write_entities(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Entities\n");
        self.output.push_str("// =============================================================\n\n");

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                self.write_entity_id_type(&entity.name);
                self.write_entity_class(&entity.name, *entity_id);
            }
        }
    }

    fn write_entity_id_type(&mut self, name: &str) {
        if self.config.use_records {
            self.output.push_str(&format!(
                r#"/**
 * Unique identifier for {{@link {name}}}.
 *
 * @param value The underlying UUID value
 */
public record {name}Id(UUID value) {{
    /**
     * Create a new random ID.
     */
    public static {name}Id create() {{
        return new {name}Id(UUID.randomUUID());
    }}

    /**
     * Create from an existing UUID.
     */
    public static {name}Id fromUUID(UUID uuid) {{
        return new {name}Id(uuid);
    }}

    /**
     * Parse from a string representation.
     */
    public static {name}Id fromString(String s) {{
        return new {name}Id(UUID.fromString(s));
    }}

    @Override
    public String toString() {{
        return value.toString();
    }}
"#
            ));

            if self.config.use_jackson {
                self.output.push_str(&format!(
                    r#"
    @JsonValue
    public String toJson() {{
        return value.toString();
    }}

    @JsonCreator
    public static {name}Id fromJson(String s) {{
        return fromString(s);
    }}
"#
                ));
            }

            self.output.push_str("}\n\n");
        } else {
            // Generate traditional class
            self.write_entity_id_class(name);
        }
    }

    fn write_entity_id_class(&mut self, name: &str) {
        self.output.push_str(&format!(
            r#"/**
 * Unique identifier for {{@link {name}}}.
 */
public final class {name}Id {{
    private final UUID value;

    public {name}Id(UUID value) {{
        this.value = Objects.requireNonNull(value);
    }}

    public UUID getValue() {{
        return value;
    }}

    public static {name}Id create() {{
        return new {name}Id(UUID.randomUUID());
    }}

    public static {name}Id fromUUID(UUID uuid) {{
        return new {name}Id(uuid);
    }}

    public static {name}Id fromString(String s) {{
        return new {name}Id(UUID.fromString(s));
    }}

    @Override
    public boolean equals(Object o) {{
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        {name}Id that = ({name}Id) o;
        return Objects.equals(value, that.value);
    }}

    @Override
    public int hashCode() {{
        return Objects.hash(value);
    }}

    @Override
    public String toString() {{
        return value.toString();
    }}
}}

"#
        ));
    }

    fn write_entity_class(&mut self, name: &str, object_id: ObjectId) {
        let is_aggregate_root = self.aggregate_roots.contains(&object_id);
        let root_note = if is_aggregate_root {
            " (Aggregate Root)"
        } else {
            ""
        };

        if self.config.use_records {
            self.write_entity_record(name, object_id, root_note);
        } else if self.config.use_lombok {
            self.write_entity_lombok(name, object_id, root_note);
        } else {
            self.write_entity_pojo(name, object_id, root_note);
        }
    }

    fn write_entity_record(&mut self, name: &str, object_id: ObjectId, root_note: &str) {
        self.output.push_str(&format!(
            r#"/**
 * Entity: {name}{root_note}
 *
 * An entity has a unique identity that persists through state changes.
 */
public record {name}(
    {name}Id id"#
        ));

        // Add fields from morphisms
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                let field_type = self.java_type_for_target(morphism.target);
                self.output.push_str(&format!(",\n    {} {}", field_type, field_name));
            }
        }

        self.output.push_str("\n) {\n");

        // Factory method
        self.output.push_str(&format!(
            "    /**\n     * Create a new {name} with a generated ID.\n     */\n"
        ));
        self.output.push_str(&format!("    public static {name} create("));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            let params: Vec<String> = morphisms
                .iter()
                .map(|m| format!("{} {}", self.java_type_for_target(m.target), to_camel_case(&m.name)))
                .collect();
            self.output.push_str(&params.join(", "));
        }

        self.output.push_str(") {\n");
        self.output.push_str(&format!("        return new {name}(\n"));
        self.output.push_str(&format!("            {name}Id.create()"));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                self.output.push_str(&format!(",\n            {field_name}"));
            }
        }

        self.output.push_str("\n        );\n    }\n}\n\n");
    }

    fn write_entity_lombok(&mut self, name: &str, object_id: ObjectId, root_note: &str) {
        self.output.push_str(&format!(
            r#"/**
 * Entity: {name}{root_note}
 *
 * An entity has a unique identity that persists through state changes.
 */
@Data
@Builder
public class {name} {{
    private final {name}Id id;
"#
        ));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                let field_type = self.java_type_for_target(morphism.target);
                self.output.push_str(&format!("    private {} {};\n", field_type, field_name));
            }
        }

        self.output.push_str(&format!(
            r#"
    public static {name} create("#
        ));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            let params: Vec<String> = morphisms
                .iter()
                .map(|m| format!("{} {}", self.java_type_for_target(m.target), to_camel_case(&m.name)))
                .collect();
            self.output.push_str(&params.join(", "));
        }

        self.output.push_str(") {\n");
        self.output.push_str(&format!("        return {name}.builder()\n"));
        self.output.push_str(&format!("            .id({name}Id.create())\n"));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                self.output.push_str(&format!("            .{field_name}({field_name})\n"));
            }
        }

        self.output.push_str("            .build();\n    }\n}\n\n");
    }

    fn write_entity_pojo(&mut self, name: &str, object_id: ObjectId, root_note: &str) {
        self.output.push_str(&format!(
            r#"/**
 * Entity: {name}{root_note}
 *
 * An entity has a unique identity that persists through state changes.
 */
public class {name} {{
    private final {name}Id id;
"#
        ));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                let field_type = self.java_type_for_target(morphism.target);
                self.output.push_str(&format!("    private {} {};\n", field_type, field_name));
            }
        }

        // Constructor
        self.output.push_str(&format!("\n    public {name}({name}Id id"));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                let field_type = self.java_type_for_target(morphism.target);
                self.output.push_str(&format!(", {} {}", field_type, field_name));
            }
        }

        self.output.push_str(") {\n");
        self.output.push_str("        this.id = Objects.requireNonNull(id);\n");

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                self.output.push_str(&format!("        this.{field_name} = {field_name};\n"));
            }
        }

        self.output.push_str("    }\n\n");

        // Getters
        self.output.push_str(&format!("    public {name}Id getId() {{ return id; }}\n"));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                let field_type = self.java_type_for_target(morphism.target);
                let getter_name = format!("get{}", capitalize_first(&field_name));
                self.output.push_str(&format!(
                    "    public {} {}() {{ return {}; }}\n",
                    field_type, getter_name, field_name
                ));
            }
        }

        // Factory method
        self.output.push_str(&format!(
            "\n    public static {name} create("
        ));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            let params: Vec<String> = morphisms
                .iter()
                .map(|m| format!("{} {}", self.java_type_for_target(m.target), to_camel_case(&m.name)))
                .collect();
            self.output.push_str(&params.join(", "));
        }

        self.output.push_str(") {\n");
        self.output.push_str(&format!("        return new {name}({name}Id.create()"));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                self.output.push_str(&format!(", {field_name}"));
            }
        }

        self.output.push_str(");\n    }\n}\n\n");
    }

    fn write_value_objects(&mut self) {
        if self.value_object_ids.is_empty() {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Value Objects\n");
        self.output.push_str("// =============================================================\n\n");

        for vo_id in self.context.value_objects() {
            if let Some(vo) = self.context.graph().get_object(*vo_id) {
                self.write_value_object(&vo.name, *vo_id);
            }
        }
    }

    fn write_value_object(&mut self, name: &str, object_id: ObjectId) {
        if self.config.use_records {
            self.output.push_str(&format!(
                r#"/**
 * Value Object: {name}
 *
 * A value object is defined by its attributes, not identity.
 * Two value objects with the same attributes are considered equal.
 */
public record {name}(
"#
            ));

            let morphisms = self.object_morphisms.get(&object_id);
            if let Some(morphisms) = morphisms {
                let fields: Vec<String> = morphisms
                    .iter()
                    .map(|m| format!("    {} {}", self.java_type_for_target(m.target), to_camel_case(&m.name)))
                    .collect();
                self.output.push_str(&fields.join(",\n"));
            }

            self.output.push_str("\n) {}\n\n");
        } else {
            self.write_value_object_class(name, object_id);
        }
    }

    fn write_value_object_class(&mut self, name: &str, object_id: ObjectId) {
        let lombok = if self.config.use_lombok { "@Value\n" } else { "" };

        self.output.push_str(&format!(
            r#"/**
 * Value Object: {name}
 *
 * A value object is defined by its attributes, not identity.
 * Two value objects with the same attributes are considered equal.
 */
{lombok}public final class {name} {{
"#
        ));

        let morphisms = self.object_morphisms.get(&object_id);

        if let Some(morphisms) = morphisms {
            for morphism in morphisms {
                let field_name = to_camel_case(&morphism.name);
                let field_type = self.java_type_for_target(morphism.target);
                self.output.push_str(&format!("    private final {} {};\n", field_type, field_name));
            }
        }

        if !self.config.use_lombok {
            // Constructor
            self.output.push_str(&format!("\n    public {name}("));

            if let Some(morphisms) = morphisms {
                let params: Vec<String> = morphisms
                    .iter()
                    .map(|m| format!("{} {}", self.java_type_for_target(m.target), to_camel_case(&m.name)))
                    .collect();
                self.output.push_str(&params.join(", "));
            }

            self.output.push_str(") {\n");

            if let Some(morphisms) = morphisms {
                for morphism in morphisms {
                    let field_name = to_camel_case(&morphism.name);
                    self.output.push_str(&format!("        this.{field_name} = {field_name};\n"));
                }
            }

            self.output.push_str("    }\n");

            // Getters
            if let Some(morphisms) = morphisms {
                for morphism in morphisms {
                    let field_name = to_camel_case(&morphism.name);
                    let field_type = self.java_type_for_target(morphism.target);
                    let getter_name = format!("get{}", capitalize_first(&field_name));
                    self.output.push_str(&format!(
                        "\n    public {} {}() {{ return {}; }}\n",
                        field_type, getter_name, field_name
                    ));
                }
            }

            // equals, hashCode, toString
            self.output.push_str(&format!(
                r#"
    @Override
    public boolean equals(Object o) {{
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        {name} that = ({name}) o;
        return "#
            ));

            if let Some(morphisms) = morphisms {
                let comparisons: Vec<String> = morphisms
                    .iter()
                    .map(|m| format!("Objects.equals({}, that.{})", to_camel_case(&m.name), to_camel_case(&m.name)))
                    .collect();
                self.output.push_str(&comparisons.join(" && "));
            } else {
                self.output.push_str("true");
            }

            self.output.push_str(";\n    }\n\n");

            self.output.push_str("    @Override\n    public int hashCode() {\n        return Objects.hash(");

            if let Some(morphisms) = morphisms {
                let fields: Vec<String> = morphisms
                    .iter()
                    .map(|m| to_camel_case(&m.name))
                    .collect();
                self.output.push_str(&fields.join(", "));
            }

            self.output.push_str(");\n    }\n");
        }

        self.output.push_str("}\n\n");
    }

    fn write_enums(&mut self) {
        let colimits = &self.context.sketch().colimits;
        if colimits.is_empty() {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Enumerations (Sum Types)\n");
        self.output.push_str("// =============================================================\n\n");

        for colimit in colimits {
            self.write_enum(colimit);
        }
    }

    fn write_enum(&mut self, colimit: &ColimitCocone) {
        let is_simple_enum = colimit.injections.iter().all(|i| i.source == colimit.apex);

        if is_simple_enum {
            self.output.push_str(&format!(
                r#"/**
 * Enumeration: {}
 *
 * A simple enumeration of possible values.
 */
public enum {} {{
"#,
                colimit.name, colimit.name
            ));

            for (i, injection) in colimit.injections.iter().enumerate() {
                if i < colimit.injections.len() - 1 {
                    self.output.push_str(&format!("    {},\n", injection.name.to_uppercase()));
                } else {
                    self.output.push_str(&format!("    {}\n", injection.name.to_uppercase()));
                }
            }

            self.output.push_str("}\n\n");
        } else {
            // Generate sealed interface (Java 17+) or abstract class
            if self.config.use_records {
                self.write_sealed_sum_type(colimit);
            } else {
                self.write_abstract_sum_type(colimit);
            }
        }
    }

    fn write_sealed_sum_type(&mut self, colimit: &ColimitCocone) {
        let variant_names: Vec<String> = colimit
            .injections
            .iter()
            .map(|i| format!("{}.{}", colimit.name, i.name))
            .collect();

        self.output.push_str(&format!(
            r#"/**
 * Sum Type: {}
 *
 * A sealed hierarchy representing one of several possible variants.
 */
public sealed interface {} permits {} {{
"#,
            colimit.name, colimit.name, variant_names.join(", ")
        ));

        for injection in &colimit.injections {
            let variant_type = self
                .object_names
                .get(&injection.source)
                .cloned()
                .unwrap_or_else(|| "Object".to_string());

            self.output.push_str(&format!(
                "    record {}({} value) implements {} {{}}\n",
                injection.name, variant_type, colimit.name
            ));
        }

        self.output.push_str("}\n\n");
    }

    fn write_abstract_sum_type(&mut self, colimit: &ColimitCocone) {
        self.output.push_str(&format!(
            r#"/**
 * Sum Type: {}
 *
 * An abstract base class representing one of several possible variants.
 */
public abstract class {} {{
    private {}() {{}}  // Prevent external subclassing

"#,
            colimit.name, colimit.name, colimit.name
        ));

        for injection in &colimit.injections {
            let variant_type = self
                .object_names
                .get(&injection.source)
                .cloned()
                .unwrap_or_else(|| "Object".to_string());

            self.output.push_str(&format!(
                r#"    public static final class {} extends {} {{
        private final {} value;

        public {}({} value) {{
            this.value = value;
        }}

        public {} getValue() {{
            return value;
        }}
    }}

"#,
                injection.name, colimit.name, variant_type,
                injection.name, variant_type, variant_type
            ));
        }

        self.output.push_str("}\n\n");
    }

    fn write_aggregates(&mut self) {
        let limits: Vec<_> = self
            .context
            .sketch()
            .limits
            .iter()
            .filter(|l| l.is_aggregate)
            .collect();

        if limits.is_empty() || !self.config.generate_validation {
            return;
        }

        self.output.push_str("// =============================================================\n");
        self.output.push_str("// Aggregate Validation\n");
        self.output.push_str("// =============================================================\n\n");

        self.write_validation_error();

        for limit in limits {
            self.write_aggregate_validation(limit);
        }
    }

    fn write_validation_error(&mut self) {
        if self.config.use_records {
            self.output.push_str(
                r#"/**
 * Error returned when aggregate validation fails.
 */
public record ValidationError(String invariant, String message) {}

/**
 * Result type for validation operations.
 */
public sealed interface ValidationResult<T> {
    record Success<T>(T value) implements ValidationResult<T> {}
    record Failure<T>(List<ValidationError> errors) implements ValidationResult<T> {}

    static <T> ValidationResult<T> success(T value) {
        return new Success<>(value);
    }

    static <T> ValidationResult<T> failure(List<ValidationError> errors) {
        return new Failure<>(errors);
    }

    static <T> ValidationResult<T> failure(String invariant, String message) {
        return new Failure<>(List.of(new ValidationError(invariant, message)));
    }
}

"#,
            );
        } else {
            self.output.push_str(
                r#"/**
 * Error returned when aggregate validation fails.
 */
public class ValidationError {
    private final String invariant;
    private final String message;

    public ValidationError(String invariant, String message) {
        this.invariant = invariant;
        this.message = message;
    }

    public String getInvariant() { return invariant; }
    public String getMessage() { return message; }
}

/**
 * Result type for validation operations.
 */
public abstract class ValidationResult<T> {
    private ValidationResult() {}

    public static <T> ValidationResult<T> success(T value) {
        return new Success<>(value);
    }

    public static <T> ValidationResult<T> failure(List<ValidationError> errors) {
        return new Failure<>(errors);
    }

    public abstract boolean isSuccess();
    public abstract T getValue();
    public abstract List<ValidationError> getErrors();

    public static final class Success<T> extends ValidationResult<T> {
        private final T value;
        public Success(T value) { this.value = value; }
        public boolean isSuccess() { return true; }
        public T getValue() { return value; }
        public List<ValidationError> getErrors() { return List.of(); }
    }

    public static final class Failure<T> extends ValidationResult<T> {
        private final List<ValidationError> errors;
        public Failure(List<ValidationError> errors) { this.errors = errors; }
        public boolean isSuccess() { return false; }
        public T getValue() { throw new IllegalStateException("No value on failure"); }
        public List<ValidationError> getErrors() { return errors; }
    }
}

"#,
            );
        }
    }

    fn write_aggregate_validation(&mut self, limit: &LimitCone) {
        let root_id = match limit.root {
            Some(id) => id,
            None => return,
        };

        let root_name = self
            .object_names
            .get(&root_id)
            .cloned()
            .unwrap_or_else(|| "Unknown".to_string());

        self.output.push_str(&format!(
            r#"/**
 * Validator for {} aggregate.
 */
public class {}Validator {{
    /**
     * Validate {} aggregate invariants.
     */
    public static ValidationResult<{}> validate({} entity) {{
        List<ValidationError> errors = new ArrayList<>();

        // TODO: Add invariant validation logic based on model equations
        //
        // Example invariant:
        // if (!entity.getTotalPrice().equals(calculateTotal(entity.getItems()))) {{
        //     errors.add(new ValidationError("totalPrice", "totalPrice must equal sum of item prices"));
        // }}

        if (errors.isEmpty()) {{
            return ValidationResult.success(entity);
        }}
        return ValidationResult.failure(errors);
    }}

    /**
     * Validate and return the entity, throwing on failure.
     */
    public static {} validateOrThrow({} entity) {{
        ValidationResult<{}> result = validate(entity);
        if (result instanceof ValidationResult.Success<{}> success) {{
            return success.getValue();
        }}
        ValidationResult.Failure<{}> failure = (ValidationResult.Failure<{}>) result;
        throw new IllegalStateException("Validation failed: " + failure.getErrors());
    }}
}}

"#,
            limit.name, root_name, root_name, root_name, root_name,
            root_name, root_name, root_name, root_name, root_name, root_name
        ));
    }

    fn java_type_for_target(&self, target: ObjectId) -> String {
        let target_name = self
            .object_names
            .get(&target)
            .cloned()
            .unwrap_or_else(|| "Object".to_string());

        if self.entity_ids.contains(&target) {
            format!("{}Id", target_name)
        } else {
            target_name
        }
    }
}

/// Convert to Java package name.
fn to_package_name(s: &str) -> String {
    s.chars()
        .filter(|c| c.is_alphanumeric() || *c == '.')
        .collect::<String>()
        .to_lowercase()
}

/// Convert to camelCase.
fn to_camel_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = false;

    for (i, c) in s.chars().enumerate() {
        if c == '_' {
            capitalize_next = true;
        } else if i == 0 {
            result.push(c.to_ascii_lowercase());
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else if c.is_uppercase() && i > 0 {
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

/// Capitalize first letter.
fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("Customer"), "customer");
        assert_eq!(to_camel_case("line_item"), "lineItem");
        assert_eq!(to_camel_case("placed_by"), "placedBy");
    }

    #[test]
    fn test_generate_empty_context() {
        let context = BoundedContext::new("Test");
        let result = generate(&context).unwrap();

        assert!(result.contains("Generated from `Test` bounded context"));
        assert!(result.contains("package test;"));
        assert!(result.contains("import java.util.UUID;"));
    }

    #[test]
    fn test_generate_entity() {
        let mut context = BoundedContext::new("Commerce");
        let _customer = context.add_entity("Customer");

        let result = generate(&context).unwrap();

        // Should have ID record
        assert!(result.contains("public record CustomerId(UUID value)"));

        // Should have entity record
        assert!(result.contains("public record Customer("));
        assert!(result.contains("CustomerId id"));

        // Should have factory method
        assert!(result.contains("public static Customer create("));
    }

    #[test]
    fn test_generate_entity_with_morphisms() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("placed_by", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("public record Order("));
        assert!(result.contains("CustomerId placedBy"));
    }

    #[test]
    fn test_generate_value_object() {
        let mut context = BoundedContext::new("Commerce");
        let _money = context.add_value_object("Money");

        let result = generate(&context).unwrap();

        assert!(result.contains("// Value Objects"));
        assert!(result.contains("public record Money("));
    }

    #[test]
    fn test_generate_simple_enum() {
        let mut context = BoundedContext::new("Commerce");
        let _status = context.add_enum(
            "OrderStatus",
            vec!["Pending".into(), "Confirmed".into(), "Shipped".into()],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("public enum OrderStatus {"));
        assert!(result.contains("PENDING,"));
        assert!(result.contains("CONFIRMED,"));
        assert!(result.contains("SHIPPED"));
    }

    #[test]
    fn test_generate_aggregate() {
        let mut context = BoundedContext::new("Commerce");
        let order = context.add_entity("Order");
        let line_item = context.add_entity("LineItem");

        context.define_aggregate_with_members("OrderAggregate", order, &[line_item]);

        let result = generate(&context).unwrap();

        assert!(result.contains("// Aggregate Validation"));
        assert!(result.contains("public record ValidationError("));
        assert!(result.contains("public class OrderValidator {"));
        assert!(result.contains("public static ValidationResult<Order> validate(Order entity)"));
    }

    #[test]
    fn test_generate_sealed_sum_type() {
        let mut context = BoundedContext::new("Payments");

        let transaction_id = context.sketch_mut().add_object("TransactionId");
        let error_code = context.sketch_mut().add_object("ErrorCode");

        let _result = context.add_sum_type(
            "PaymentResult",
            vec![
                ("Success".into(), transaction_id),
                ("Failed".into(), error_code),
            ],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("public sealed interface PaymentResult"));
        assert!(result.contains("record Success(TransactionId value) implements PaymentResult"));
        assert!(result.contains("record Failed(ErrorCode value) implements PaymentResult"));
    }

    #[test]
    fn test_config_no_records() {
        let mut context = BoundedContext::new("Test");
        let _customer = context.add_entity("Customer");

        let config = JavaConfig {
            use_records: false,
            ..Default::default()
        };

        let result = generate_with_config(&context, &config).unwrap();

        assert!(result.contains("public final class CustomerId {"));
        assert!(result.contains("public class Customer {"));
    }

    #[test]
    fn test_entity_references_use_id_type() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("customer", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("CustomerId customer"));
    }
}
