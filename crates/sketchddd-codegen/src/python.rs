//! Python code generation for SketchDDD domain models.
//!
//! Generates idiomatic Python code from a bounded context:
//! - Entities as dataclasses with UUID IDs
//! - Value objects as frozen dataclasses
//! - Aggregates with validation methods
//! - Enums using Python's enum module
//! - Pydantic models for validation (optional)

use crate::CodegenError;
use sketchddd_core::sketch::{ColimitCocone, LimitCone, Morphism, ObjectId};
use sketchddd_core::BoundedContext;
use std::collections::{HashMap, HashSet};

/// Configuration options for Python code generation.
#[derive(Debug, Clone)]
pub struct PythonConfig {
    /// Whether to use Pydantic models instead of dataclasses
    pub use_pydantic: bool,
    /// Whether to generate type hints
    pub use_type_hints: bool,
    /// Whether to generate validation methods
    pub generate_validation: bool,
    /// Whether to generate factory methods
    pub generate_factories: bool,
    /// Module docstring
    pub module_docstring: Option<String>,
}

impl Default for PythonConfig {
    fn default() -> Self {
        Self {
            use_pydantic: false,
            use_type_hints: true,
            generate_validation: true,
            generate_factories: true,
            module_docstring: None,
        }
    }
}

/// Generate Python code from a bounded context with default configuration.
pub fn generate(context: &BoundedContext) -> Result<String, CodegenError> {
    generate_with_config(context, &PythonConfig::default())
}

/// Generate Python code from a bounded context with custom configuration.
pub fn generate_with_config(
    context: &BoundedContext,
    config: &PythonConfig,
) -> Result<String, CodegenError> {
    let mut gen = PythonGenerator::new(context, config);
    gen.generate()
}

/// Internal generator state.
struct PythonGenerator<'a> {
    context: &'a BoundedContext,
    config: &'a PythonConfig,
    output: String,
    entity_ids: HashSet<ObjectId>,
    value_object_ids: HashSet<ObjectId>,
    aggregate_roots: HashSet<ObjectId>,
    object_names: HashMap<ObjectId, String>,
    object_morphisms: HashMap<ObjectId, Vec<&'a Morphism>>,
}

impl<'a> PythonGenerator<'a> {
    fn new(context: &'a BoundedContext, config: &'a PythonConfig) -> Self {
        let entity_ids: HashSet<_> = context.entities().iter().copied().collect();
        let value_object_ids: HashSet<_> = context.value_objects().iter().copied().collect();
        let aggregate_roots: HashSet<_> = context.aggregate_roots().iter().copied().collect();

        let object_names: HashMap<_, _> = context
            .graph()
            .objects()
            .map(|o| (o.id, o.name.clone()))
            .collect();

        let mut object_morphisms: HashMap<ObjectId, Vec<&Morphism>> = HashMap::new();
        for morphism in context.graph().morphisms() {
            if !morphism.is_identity {
                object_morphisms
                    .entry(morphism.source)
                    .or_default()
                    .push(morphism);
            }
        }

        Self {
            context,
            config,
            output: String::new(),
            entity_ids,
            value_object_ids,
            aggregate_roots,
            object_names,
            object_morphisms,
        }
    }

    fn generate(&mut self) -> Result<String, CodegenError> {
        self.write_header();
        self.write_imports();
        self.write_id_types();
        self.write_entities();
        self.write_value_objects();
        self.write_enums();
        self.write_aggregates();

        Ok(std::mem::take(&mut self.output))
    }

    fn write_header(&mut self) {
        let docstring = self
            .config
            .module_docstring
            .clone()
            .unwrap_or_else(|| format!("Generated from `{}` bounded context.", self.context.name()));

        self.output.push_str(&format!(
            r#"""\"\"\"
{}

This file was automatically generated by SketchDDD.
DO NOT EDIT - changes will be overwritten.

To regenerate: `sketchddd codegen <model>.sddd --target python`
""\"\"\"

from __future__ import annotations

"#,
            docstring
        ));
    }

    fn write_imports(&mut self) {
        self.output.push_str("from dataclasses import dataclass, field\n");
        self.output.push_str("from enum import Enum, auto\n");

        if self.config.use_type_hints {
            self.output.push_str("from typing import List, Optional, NewType, Union\n");
        }

        self.output.push_str("from uuid import UUID, uuid4\n");

        if self.config.use_pydantic {
            self.output.push_str("from pydantic import BaseModel, Field, validator\n");
        }

        self.output.push_str("\n\n");
    }

    fn write_id_types(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str("# =============================================================\n");
        self.output.push_str("# Entity ID Types\n");
        self.output.push_str("# =============================================================\n\n");

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                self.output.push_str(&format!(
                    r#"# Type alias for {} identifiers
{}Id = NewType("{}Id", UUID)


def create_{}_id() -> {}Id:
    """Create a new random {} ID."""
    return {}Id(uuid4())


"#,
                    entity.name,
                    entity.name,
                    entity.name,
                    to_snake_case(&entity.name),
                    entity.name,
                    entity.name,
                    entity.name
                ));
            }
        }
    }

    fn write_entities(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str("# =============================================================\n");
        self.output.push_str("# Entities\n");
        self.output.push_str("# =============================================================\n\n");

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                self.write_entity(&entity.name, *entity_id);
            }
        }
    }

    fn write_entity(&mut self, name: &str, object_id: ObjectId) {
        let is_aggregate_root = self.aggregate_roots.contains(&object_id);
        let root_note = if is_aggregate_root {
            " (Aggregate Root)"
        } else {
            ""
        };

        if self.config.use_pydantic {
            self.write_pydantic_entity(name, object_id, root_note);
        } else {
            self.write_dataclass_entity(name, object_id, root_note);
        }
    }

    fn write_dataclass_entity(&mut self, name: &str, object_id: ObjectId, root_note: &str) {
        self.output.push_str(&format!(
            r#"@dataclass
class {name}:
    """
    Entity: {name}{root_note}

    An entity has a unique identity that persists through state changes.
    """

    id: {name}Id = field(default_factory=create_{snake_name}_id)
"#,
            snake_name = to_snake_case(name)
        ));

        // Add fields from morphisms
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_snake_case(&morphism.name);
                let field_type = self.python_type_for_target(morphism.target);

                if let Some(desc) = &morphism.description {
                    self.output.push_str(&format!("    # {}\n", desc));
                }
                self.output.push_str(&format!("    {}: {}\n", field_name, field_type));
            }
        }

        self.output.push_str("\n");

        // Factory method
        if self.config.generate_factories {
            self.write_entity_factory(name, object_id);
        }

        self.output.push_str("\n");
    }

    fn write_pydantic_entity(&mut self, name: &str, object_id: ObjectId, root_note: &str) {
        self.output.push_str(&format!(
            r#"class {name}(BaseModel):
    """
    Entity: {name}{root_note}

    An entity has a unique identity that persists through state changes.
    """

    id: {name}Id = Field(default_factory=lambda: {name}Id(uuid4()))
"#
        ));

        // Add fields from morphisms
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_snake_case(&morphism.name);
                let field_type = self.python_type_for_target(morphism.target);
                let desc = morphism.description.as_deref().unwrap_or("");

                self.output.push_str(&format!(
                    "    {}: {} = Field(..., description=\"{}\")\n",
                    field_name, field_type, desc
                ));
            }
        }

        self.output.push_str("\n    class Config:\n");
        self.output.push_str("        frozen = False  # Entities are mutable\n");
        self.output.push_str("\n\n");
    }

    fn write_entity_factory(&mut self, name: &str, object_id: ObjectId) {
        let snake_name = to_snake_case(name);

        self.output.push_str(&format!("def create_{snake_name}("));

        // Parameters
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            let params: Vec<String> = morphisms
                .iter()
                .map(|m| format!("{}: {}", to_snake_case(&m.name), self.python_type_for_target(m.target)))
                .collect();
            self.output.push_str(&params.join(", "));
        }

        self.output.push_str(&format!(") -> {name}:\n"));
        self.output.push_str(&format!("    \"\"\"Create a new {name} with a generated ID.\"\"\"\n"));
        self.output.push_str(&format!("    return {name}(\n"));
        self.output.push_str(&format!("        id=create_{snake_name}_id(),\n"));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_snake_case(&morphism.name);
                self.output.push_str(&format!("        {field_name}={field_name},\n"));
            }
        }

        self.output.push_str("    )\n");
    }

    fn write_value_objects(&mut self) {
        if self.value_object_ids.is_empty() {
            return;
        }

        self.output.push_str("# =============================================================\n");
        self.output.push_str("# Value Objects\n");
        self.output.push_str("# =============================================================\n\n");

        for vo_id in self.context.value_objects() {
            if let Some(vo) = self.context.graph().get_object(*vo_id) {
                self.write_value_object(&vo.name, *vo_id);
            }
        }
    }

    fn write_value_object(&mut self, name: &str, object_id: ObjectId) {
        let limit_cone = self.context.get_value_object_limit(object_id);

        if self.config.use_pydantic {
            self.output.push_str(&format!(
                r#"class {name}(BaseModel):
    """
    Value Object: {name}

    A value object is defined by its attributes, not identity.
    Two value objects with the same attributes are considered equal.
    """

"#
            ));

            // Add fields
            let morphisms = self.object_morphisms.get(&object_id);
            if let Some(morphisms) = morphisms {
                for morphism in morphisms {
                    let field_name = to_snake_case(&morphism.name);
                    let field_type = self.python_type_for_target(morphism.target);
                    self.output.push_str(&format!("    {}: {}\n", field_name, field_type));
                }
            } else if let Some(cone) = limit_cone {
                for proj in &cone.projections {
                    if let Some(m) = self.context.graph().get_morphism(proj.morphism) {
                        let field_name = to_snake_case(&m.name);
                        let field_type = self.python_type_for_target(m.target);
                        self.output.push_str(&format!("    {}: {}\n", field_name, field_type));
                    }
                }
            } else {
                self.output.push_str("    pass\n");
            }

            self.output.push_str("\n    class Config:\n");
            self.output.push_str("        frozen = True  # Value objects are immutable\n");
        } else {
            self.output.push_str(&format!(
                r#"@dataclass(frozen=True)
class {name}:
    """
    Value Object: {name}

    A value object is defined by its attributes, not identity.
    Two value objects with the same attributes are considered equal.
    """

"#
            ));

            // Add fields
            let morphisms = self.object_morphisms.get(&object_id);
            if let Some(morphisms) = morphisms {
                for morphism in morphisms {
                    let field_name = to_snake_case(&morphism.name);
                    let field_type = self.python_type_for_target(morphism.target);
                    self.output.push_str(&format!("    {}: {}\n", field_name, field_type));
                }
            } else if let Some(cone) = limit_cone {
                for proj in &cone.projections {
                    if let Some(m) = self.context.graph().get_morphism(proj.morphism) {
                        let field_name = to_snake_case(&m.name);
                        let field_type = self.python_type_for_target(m.target);
                        self.output.push_str(&format!("    {}: {}\n", field_name, field_type));
                    }
                }
            } else {
                self.output.push_str("    pass\n");
            }
        }

        self.output.push_str("\n\n");
    }

    fn write_enums(&mut self) {
        let colimits = &self.context.sketch().colimits;
        if colimits.is_empty() {
            return;
        }

        self.output.push_str("# =============================================================\n");
        self.output.push_str("# Enumerations (Sum Types)\n");
        self.output.push_str("# =============================================================\n\n");

        for colimit in colimits {
            self.write_enum(colimit);
        }
    }

    fn write_enum(&mut self, colimit: &ColimitCocone) {
        // Check if this is a simple enum or a sum type with payloads
        let is_simple_enum = colimit.injections.iter().all(|i| i.source == colimit.apex);

        if is_simple_enum {
            self.output.push_str(&format!(
                r#"class {}(Enum):
    """
    Enumeration: {}

    A simple enumeration of possible values.
    """

"#,
                colimit.name, colimit.name
            ));

            for injection in &colimit.injections {
                let const_name = to_screaming_snake_case(&injection.name);
                self.output.push_str(&format!("    {} = auto()\n", const_name));
            }

            self.output.push_str("\n\n");
        } else {
            // Generate tagged union using dataclasses
            self.output.push_str(&format!(
                r#"# Sum Type: {}
# A tagged union representing one of several possible variants.

"#,
                colimit.name
            ));

            // Generate base class
            self.output.push_str(&format!(
                r#"@dataclass
class {}Base:
    """Base class for {} variants."""
    pass


"#,
                colimit.name, colimit.name
            ));

            // Generate variant classes
            for injection in &colimit.injections {
                let variant_type = self
                    .object_names
                    .get(&injection.source)
                    .cloned()
                    .unwrap_or_else(|| "object".to_string());

                self.output.push_str(&format!(
                    r#"@dataclass
class {}{name}({}Base):
    """Variant: {name}"""
    value: {}


"#,
                    colimit.name,
                    colimit.name,
                    variant_type,
                    name = injection.name
                ));
            }

            // Generate type alias
            let variant_types: Vec<String> = colimit
                .injections
                .iter()
                .map(|i| format!("{}{}", colimit.name, i.name))
                .collect();

            self.output.push_str(&format!(
                "{} = Union[{}]\n\n\n",
                colimit.name,
                variant_types.join(", ")
            ));

            // Generate type guard functions
            for injection in &colimit.injections {
                let fn_name = format!("is_{}_{}", to_snake_case(&colimit.name), to_snake_case(&injection.name));
                let variant_type = format!("{}{}", colimit.name, injection.name);

                self.output.push_str(&format!(
                    r#"def {fn_name}(value: {}) -> bool:
    """Check if value is the {} variant."""
    return isinstance(value, {variant_type})


"#,
                    colimit.name, injection.name
                ));
            }
        }
    }

    fn write_aggregates(&mut self) {
        let limits: Vec<_> = self
            .context
            .sketch()
            .limits
            .iter()
            .filter(|l| l.is_aggregate)
            .collect();

        if limits.is_empty() || !self.config.generate_validation {
            return;
        }

        self.output.push_str("# =============================================================\n");
        self.output.push_str("# Aggregate Validation\n");
        self.output.push_str("# =============================================================\n\n");

        self.write_validation_error();

        for limit in limits {
            self.write_aggregate_validation(limit);
        }
    }

    fn write_validation_error(&mut self) {
        self.output.push_str(
            r#"@dataclass
class ValidationError:
    """Error returned when aggregate validation fails."""

    invariant: str
    message: str


@dataclass
class ValidationResult:
    """Result type for validation operations."""

    success: bool
    value: Optional[object] = None
    errors: List[ValidationError] = field(default_factory=list)

    @classmethod
    def ok(cls, value: object) -> "ValidationResult":
        """Create a successful validation result."""
        return cls(success=True, value=value)

    @classmethod
    def fail(cls, errors: List[ValidationError]) -> "ValidationResult":
        """Create a failed validation result."""
        return cls(success=False, errors=errors)

    @classmethod
    def fail_single(cls, invariant: str, message: str) -> "ValidationResult":
        """Create a failed validation result from a single error."""
        return cls(success=False, errors=[ValidationError(invariant, message)])


"#,
        );
    }

    fn write_aggregate_validation(&mut self, limit: &LimitCone) {
        let root_id = match limit.root {
            Some(id) => id,
            None => return,
        };

        let root_name = self
            .object_names
            .get(&root_id)
            .cloned()
            .unwrap_or_else(|| "Unknown".to_string());

        let snake_name = to_snake_case(&root_name);

        self.output.push_str(&format!(
            r#"def validate_{snake_name}(entity: {root_name}) -> ValidationResult:
    """
    Validate {root_name} aggregate invariants.

    Call this function after making changes to ensure the aggregate
    is in a valid state.
    """
    errors: List[ValidationError] = []

    # TODO: Add invariant validation logic based on model equations
    #
    # Example invariant:
    # if entity.total_price != sum(item.price for item in entity.items):
    #     errors.append(ValidationError(
    #         invariant="total_price",
    #         message="total_price must equal sum of item prices"
    #     ))

    if errors:
        return ValidationResult.fail(errors)

    return ValidationResult.ok(entity)


def validate_{snake_name}_or_raise(entity: {root_name}) -> {root_name}:
    """Validate and return the entity, raising ValueError on failure."""
    result = validate_{snake_name}(entity)
    if not result.success:
        error_msgs = "; ".join(f"{{e.invariant}}: {{e.message}}" for e in result.errors)
        raise ValueError(f"Validation failed: {{error_msgs}}")
    return entity


"#
        ));
    }

    fn python_type_for_target(&self, target: ObjectId) -> String {
        let target_name = self
            .object_names
            .get(&target)
            .cloned()
            .unwrap_or_else(|| "object".to_string());

        if self.entity_ids.contains(&target) {
            format!("{}Id", target_name)
        } else {
            target_name
        }
    }
}

/// Convert PascalCase to snake_case.
fn to_snake_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4);
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

/// Convert to SCREAMING_SNAKE_CASE.
fn to_screaming_snake_case(s: &str) -> String {
    to_snake_case(s).to_uppercase()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("Customer"), "customer");
        assert_eq!(to_snake_case("OrderId"), "order_id");
        assert_eq!(to_snake_case("LineItem"), "line_item");
    }

    #[test]
    fn test_to_screaming_snake_case() {
        assert_eq!(to_screaming_snake_case("Pending"), "PENDING");
        assert_eq!(to_screaming_snake_case("InProgress"), "IN_PROGRESS");
    }

    #[test]
    fn test_generate_empty_context() {
        let context = BoundedContext::new("Test");
        let result = generate(&context).unwrap();

        assert!(result.contains("Generated from `Test` bounded context"));
        assert!(result.contains("from dataclasses import"));
        assert!(result.contains("from uuid import UUID"));
    }

    #[test]
    fn test_generate_entity() {
        let mut context = BoundedContext::new("Commerce");
        let _customer = context.add_entity("Customer");

        let result = generate(&context).unwrap();

        // Should have ID type
        assert!(result.contains("CustomerId = NewType(\"CustomerId\", UUID)"));
        assert!(result.contains("def create_customer_id() -> CustomerId:"));

        // Should have entity class
        assert!(result.contains("@dataclass"));
        assert!(result.contains("class Customer:"));
        assert!(result.contains("id: CustomerId"));

        // Should have factory
        assert!(result.contains("def create_customer("));
    }

    #[test]
    fn test_generate_entity_with_morphisms() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("placed_by", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("class Order:"));
        assert!(result.contains("placed_by: CustomerId"));
    }

    #[test]
    fn test_generate_value_object() {
        let mut context = BoundedContext::new("Commerce");
        let _money = context.add_value_object("Money");

        let result = generate(&context).unwrap();

        assert!(result.contains("# Value Objects"));
        assert!(result.contains("@dataclass(frozen=True)"));
        assert!(result.contains("class Money:"));
    }

    #[test]
    fn test_generate_simple_enum() {
        let mut context = BoundedContext::new("Commerce");
        let _status = context.add_enum(
            "OrderStatus",
            vec!["Pending".into(), "Confirmed".into(), "Shipped".into()],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("class OrderStatus(Enum):"));
        assert!(result.contains("PENDING = auto()"));
        assert!(result.contains("CONFIRMED = auto()"));
        assert!(result.contains("SHIPPED = auto()"));
    }

    #[test]
    fn test_generate_aggregate() {
        let mut context = BoundedContext::new("Commerce");
        let order = context.add_entity("Order");
        let line_item = context.add_entity("LineItem");

        context.define_aggregate_with_members("OrderAggregate", order, &[line_item]);

        let result = generate(&context).unwrap();

        assert!(result.contains("# Aggregate Validation"));
        assert!(result.contains("class ValidationError:"));
        assert!(result.contains("def validate_order(entity: Order) -> ValidationResult:"));
        assert!(result.contains("def validate_order_or_raise(entity: Order) -> Order:"));
    }

    #[test]
    fn test_generate_sum_type() {
        let mut context = BoundedContext::new("Payments");

        let transaction_id = context.sketch_mut().add_object("TransactionId");
        let error_code = context.sketch_mut().add_object("ErrorCode");

        let _result = context.add_sum_type(
            "PaymentResult",
            vec![
                ("Success".into(), transaction_id),
                ("Failed".into(), error_code),
            ],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("class PaymentResultBase:"));
        assert!(result.contains("class PaymentResultSuccess(PaymentResultBase):"));
        assert!(result.contains("class PaymentResultFailed(PaymentResultBase):"));
        assert!(result.contains("PaymentResult = Union[PaymentResultSuccess, PaymentResultFailed]"));
        assert!(result.contains("def is_payment_result_success("));
    }

    #[test]
    fn test_config_pydantic() {
        let mut context = BoundedContext::new("Test");
        let _customer = context.add_entity("Customer");

        let config = PythonConfig {
            use_pydantic: true,
            ..Default::default()
        };

        let result = generate_with_config(&context, &config).unwrap();

        assert!(result.contains("from pydantic import BaseModel"));
        assert!(result.contains("class Customer(BaseModel):"));
        assert!(result.contains("class Config:"));
    }

    #[test]
    fn test_entity_references_use_id_type() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("customer", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("customer: CustomerId"));
    }
}
